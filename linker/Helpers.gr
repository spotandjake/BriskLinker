// Imports
import Bytes from "bytes"
import List from "list"
import Option from "option"
import String from "string"
import Utils from "./Utils"
// Types
export enum WasmSection {
  // SectionType(Length, Body)
  CustomSection(Number, Bytes),
  TypeSection(Number, Bytes),
  ImportSection(Number, Bytes),
  FunctionSection(Number, Bytes),
  TableSection(Number, Bytes),
  MemorySection(Number, Bytes),
  GlobalSection(Number, Bytes),
  ExportSection(Number, Bytes),
  StartSection(Number, Bytes),
  ElementSection(Number, Bytes),
  CodeSection(Number, Bytes),
  DataSection(Number, Bytes),
  DataCountSection(Number, Bytes),
}
export record LinkingInfo {
  // Language Import Identifier
  importIdentifier: String,
  // The file functionOffsetGlobal Index
  functionOffsetGlobal: Number,
  // TODO: Look into weather the relativity works here
  // Function Reference List<Positions> relative to the code section
  functionReferences: List<Number>,
  // Type References List<Positions> relative to the code section
  typeReferences: List<Number>,
  // Global References List<Positions> relative to the code section
  globalReferences: List<Number>,
}
// SectionDecoder
export let sectionDecoder = bytes => {
  let mut sections = []
  let mut offset = 0
  while (offset < Bytes.length(bytes)) {
    // Get Section Id
    let sectionID = Utils.getByte(bytes, offset)
    // Get The Section Length
    let (sectionLength, newOffset) = Utils.getUnsignedLEB128(bytes, offset + 1)
    // Get The Section Contents
    let sectionContents = Bytes.slice(newOffset, sectionLength, bytes)
    let newOffset = newOffset + sectionLength
    // Match The Section
    let section = match (sectionID) {
      0x00 => CustomSection(sectionLength, sectionContents),
      0x01 => TypeSection(sectionLength, sectionContents),
      0x02 => ImportSection(sectionLength, sectionContents),
      0x03 => FunctionSection(sectionLength, sectionContents),
      0x04 => TableSection(sectionLength, sectionContents),
      0x05 => MemorySection(sectionLength, sectionContents),
      0x06 => GlobalSection(sectionLength, sectionContents),
      0x07 => ExportSection(sectionLength, sectionContents),
      0x08 => StartSection(sectionLength, sectionContents),
      0x09 => ElementSection(sectionLength, sectionContents),
      0x0a => CodeSection(sectionLength, sectionContents),
      0x0b => DataSection(sectionLength, sectionContents),
      0x0c => DataCountSection(sectionLength, sectionContents),
      _ => fail "Invalid Section",
    }
    // Add The Section To The List
    sections = [section, ...sections]
    offset = newOffset
  }
  // Check If There Were Any Errors
  List.reverse(sections)
}
// Constants
let linkingInfoId = "LinkingInfo"
let linkingInfoIdLen = String.length(linkingInfoId) + 1
// Parsers
export let getLinkingInfo = (wasmSections: List<WasmSection>) => {
  // Find The Custom Sections
  let customSections = List.filter((section) => {
    match (section) {
      CustomSection(_, _) => true,
      _ => false,
    }
  }, wasmSections)
  if (List.length(customSections) <= 0) fail "Could Not Find A LinkingInfo Section"
  // Look For The Linking Section
  let linkingInfoSections = List.filter((section) => {
    match (section) {
      CustomSection(_, content) => Utils.getString(content, 0) == (linkingInfoId, linkingInfoIdLen),
      _ => false,
    }
  }, wasmSections)
  if (List.length(linkingInfoSections) <= 0) fail "Could Not Find A LinkingInfo Section"
  if (List.length(linkingInfoSections) > 1) fail "Found Multiple LinkingInfo Sections"
  // Decode The First Linking Section
  let linkingInfoSection = List.nth(0, linkingInfoSections)
  match (linkingInfoSection) {
    Some(CustomSection(length, content)) => {
      // Reference Sections
      let mut functionReferences = [];
      let mut typeReferences = [];
      let mut globalReferences = [];
      // Begin Decoding
      let (importIdentifier, offset) = Utils.getString(content, linkingInfoIdLen)
      let (functionOffsetGlobal, offset) = Utils.getUnsignedLEB128(content, offset)
      // Decode Reference Sections
      let mut (functionReferenceLength, offset) = Utils.getUnsignedLEB128(content, offset)
      for (let mut i = 0; i < functionReferenceLength; i += 1) {
        let (reference, newOffset) = Utils.getUnsignedLEB128(content, offset)
        offset = newOffset
        // Add The Reference
        functionReferences = [reference, ...functionReferences]
      }
      let mut (typeReferenceLength, offset) = Utils.getUnsignedLEB128(content, offset)
      for (let mut i = 0; i < typeReferenceLength; i += 1) {
        let (reference, newOffset) = Utils.getUnsignedLEB128(content, offset)
        offset = newOffset
        // Add The Reference
        typeReferences = [reference, ...typeReferences]
      }
      let mut (globalReferenceLength, offset) = Utils.getUnsignedLEB128(content, offset)
      for (let mut i = 0; i < globalReferenceLength; i += 1) {
        let (reference, newOffset) = Utils.getUnsignedLEB128(content, offset)
        offset = newOffset
        // Add The Reference
        globalReferences = [reference, ...globalReferences]
      }
      {
        importIdentifier,
        functionOffsetGlobal: functionOffsetGlobal,
        functionReferences: functionReferences,
        typeReferences: typeReferences,
        globalReferences: globalReferences,
      }
    },
    _ => fail "Could Not Find A LinkingInfo Section",
  }
}
