// Imports
import Stream from "./Stream"
import { reverse, init, find } from "list"
// Types
export enum WasmSection {
  // SectionType(Length, Body)
  CustomSection(Number, Stream.Stream),
  TypeSection(Number, Stream.Stream),
  ImportSection(Number, Stream.Stream),
  FunctionSection(Number, Stream.Stream),
  TableSection(Number, Stream.Stream),
  MemorySection(Number, Stream.Stream),
  GlobalSection(Number, Stream.Stream),
  ExportSection(Number, Stream.Stream),
  StartSection(Number, Stream.Stream),
  ElementSection(Number, Stream.Stream),
  CodeSection(Number, Stream.Stream),
  DataSection(Number, Stream.Stream),
  DataCountSection(Number, Stream.Stream),
}
export enum WasmType {
  I32,
  I64,
  F32,
  F64,
  FunctionType(List<WasmType>, List<WasmType>),
  TypeIndex(Number),
}
export enum WasmImportDesc {
  // TypeReference
  FunctionImport(Number),
  // TODO: Table
  // TODO: Memory
  // Mutable, Type
  GlobalImport(Bool, WasmType),
}
export record LinkingInfo {
  // Language Import Identifier
  importIdentifier: String,
  // The file functionOffsetGlobal Index
  functionOffsetGlobal: Number,
  // Function Reference List<Positions> relative to the code section
  functionReferences: List<Number>,
  // Type References List<Positions> relative to the code section
  typeReferences: List<Number>,
  // Global References List<Positions> relative to the code section
  globalReferences: List<Number>,
}
export record ImportInfo {
  importModule: String,
  importName: String,
  importDesc: WasmImportDesc,
}
// SectionDecoder
export let sectionDecoder = stream => {
  let mut sections = []
  while (Stream.remainingLength(stream) > 0) {
    // Get Section Id
    let sectionID = Stream.nextByte(stream)
    // Get The Section Length
    let sectionLength = Stream.nextUIntLEB128(stream)
    // Get The Section Contents
    let sectionContents = Stream.nextStreamSlice(stream, sectionLength)
    // Match The Section
    let section = match (sectionID) {
      0x00 => CustomSection(sectionLength, sectionContents),
      0x01 => TypeSection(sectionLength, sectionContents),
      0x02 => ImportSection(sectionLength, sectionContents),
      0x03 => FunctionSection(sectionLength, sectionContents),
      0x04 => TableSection(sectionLength, sectionContents),
      0x05 => MemorySection(sectionLength, sectionContents),
      0x06 => GlobalSection(sectionLength, sectionContents),
      0x07 => ExportSection(sectionLength, sectionContents),
      0x08 => StartSection(sectionLength, sectionContents),
      0x09 => ElementSection(sectionLength, sectionContents),
      0x0a => CodeSection(sectionLength, sectionContents),
      0x0b => DataSection(sectionLength, sectionContents),
      0x0c => DataCountSection(sectionLength, sectionContents),
      _ => fail "Invalid Section",
    }
    // Add The Section To The List
    sections = [section, ...sections]
  }
  // Check If There Were Any Errors
  reverse(sections)
}
// SectionDecoders Helper
let decodeSectionHeader = stream => {
  // Get The Number Of Elements In The Section
  Stream.nextUIntLEB128(stream)
}
let decodeWasmType = stream => {
  // Get Wasm Type
  let wasmType = Stream.nextByte(stream)
  // TODO: Make Sure We Can Parse All Types
  match (wasmType) {
    0x7f => I32,
    0x7e => I64,
    0x7d => F32,
    0x7c => F64,
    _ => fail "Invalid Wasm Type: " ++ toString(wasmType),
  }
}
// Section Decoders
export let decodeImportSection = sections => {
  // Find The Import Sections
  let importSection = find(section => match (section) {
    ImportSection(_, _) => true,
    _ => false,
  }, sections)
  match (importSection) {
    // Parse The Section
    Some(ImportSection(_, stream)) => {
      let mut imports = []
      // Set The Stream Position To 0
      Stream.resetPointer(stream)
      // Decode The Section Header
      let importCount = decodeSectionHeader(stream)
      // Parse Each Import
      for (let mut i = 0; i < importCount; i += 1) {
        // Get The Import Module
        let importModule = Stream.nextString(stream)
        // Get The Import Name
        let importName = Stream.nextString(stream)
        // Get The Import Type
        let importKind = Stream.nextByte(stream)
        let importDesc = match (importKind) {
          // Function Import
          0x00 => {
            // Get The Function Type Index
            let functionIndex = Stream.nextUIntLEB128(stream)
            FunctionImport(functionIndex)
          },
          // TODO: Table Import
          0x01 => fail "Table Import Not Yet Implemented",
          // TODO: Memory Import
          0x02 => fail "Memory Import Not Yet Implemented",
          // Global Import
          0x03 => {
            // Get Global Type
            let globalType = decodeWasmType(stream)
            // Get Global Mutability
            let globalMutable = Stream.nextByte(stream) == 0x01
            // Return Description
            GlobalImport(globalMutable, globalType)
          },
          _ => fail "Invalid Import Kind",
        }
        // Add The Import To ImportList
        imports = [{ importModule, importName, importDesc }, ...imports]
      }
      // Return A List Of Imports
      imports
    },
    // If There Is No Import Section Then There Are No Imports
    _ => [],
  }
}
// Decode Linking Info Section
let getRefs = s =>
  init(Stream.nextUIntLEB128(s), (_) => Stream.nextUIntLEB128(s))
export let getLinkingInfo = sections => {
  // Find The LinkingInfo Section
  let linkingInfo = find(section => match (section) {
    CustomSection(_, stream) when Stream.nextString(stream) == "LinkingInfo" =>
      true,
    _ => false,
  }, sections)
  // If We Did Not Find The Section Fail
  match (linkingInfo) {
    Some(CustomSection(_, stream)) => {
      // Package
      {
        importIdentifier: Stream.nextString(stream),
        functionOffsetGlobal: Stream.nextUIntLEB128(stream),
        functionReferences: getRefs(stream),
        typeReferences: getRefs(stream),
        globalReferences: getRefs(stream),
      }
    },
    _ => fail "Linking Info Section Not Found",
  }
}
