// Imports
import {
  WasmSection,
  ImportInfo,
  sectionDecoder,
  getLinkingInfo,
  decodeImportSection,
} from "./Helpers"
import Stream from "./Stream"
import List from "list"
import String from "string"
// Types
export record FileData {
  importIdentifier: String,
  wasmSections: List<WasmSection>,
  wasmBinary: Bytes,
  functionReferences: List<Number>,
  typeReferences: List<Number>,
  globalReferences: List<Number>,
  mut dependencies: List<String>,
}
// Decodes A Wasm File
export let decodeFile = wasmBinary => {
  // Create Our Stream
  let stream = Stream.fromBytes(wasmBinary)
  // Ensure The File Is Valid
  if (Stream.nextSliceList(stream, 4) != [0x00, 0x61, 0x73, 0x6d]) {
    fail "File Missing Wasm Magic Number"
  }
  if (Stream.nextSliceList(stream, 4) != [0x01, 0x00, 0x00, 0x00]) {
    fail "File Missing Wasm Version"
  }
  // Split File Into Sections
  let wasmSections = sectionDecoder(stream)
  // Parse LinkingInfo Section
  let linkingInfo = getLinkingInfo(wasmSections)
  // TODO: Parse Import Section
  let imports = decodeImportSection(wasmSections)
  // Parse Section Headers To Determine The Number Of Things Like Functions, Globals, Imports, Exports, And other important data
  // TODO: Find Relevant Imports
  // TODO: I Should not need a type cast there, but the inferring seems to be broken
  let briskImports = List.map((importData: ImportInfo) => importData.importModule, List.filter((importData: ImportInfo) =>
    String.startsWith(
      linkingInfo.importIdentifier,
      importData.importModule
    ), imports))
  // TODO: Build File Map
  // TODO: Return A Result
  {
    importIdentifier: linkingInfo.importIdentifier,
    wasmSections,
    wasmBinary,
    functionReferences: linkingInfo.functionReferences,
    typeReferences: linkingInfo.typeReferences,
    globalReferences: linkingInfo.globalReferences,
    dependencies: briskImports,
  }
}
