// Imports
import Buffer from "buffer"
import List from "list"
import Map from "map"
import Int32 from "int32"
import Bytes from "bytes"
import Stream from "./Stream"
import DecodeSection, {
  getTypeSection,
  getFuncSection,
  getTableSection,
  getGlobalSection,
  getCodeSection,
} from "./Decoder/DecodeSection"
import WasmDecoder from "./Decoder/WasmDecoder"
import Encoder from "./encode"
// Type Imports
import DecodeFile from "./Decoder/DecodeFile"
// Types
record WasmData {
  mut globalCount: Number,
  mut typeCount: Number,
  mut functionCount: Number,
}
// Buffer Manipulation
let appendBufferByte = (buffer, byte) => {
  Buffer.addInt8(Int32.fromNumber(byte), buffer)
  buffer
}
let appendBufferByteList = (buffer, byteList) => {
  let mut buffer = buffer
  List.forEach(byte => {
    buffer = appendBufferByte(buffer, byte)
    void
  }, byteList)
  buffer
}
// Create The Sections
export let createTypeSection = (wasmBinary, dependencyChain, wasmData) => {
  let mut typeCount = 0
  let typeSection = Buffer.make(0)
  // For Each Dependency
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The Type Section
    let typeStream = getTypeSection(dependency.wasmSections)
    // Skip This Dependency If There Is Not A Type Section
    if (!Stream.isEmpty(typeStream)) {
      // Decode The Number Of Types
      let numberOfTypes = Stream.nextUIntLEB128(typeStream)
      // Map Types
      for (let mut i = 0; i < numberOfTypes; i += 1) {
        // Write The Offset
        Map.set(i, wasmData.typeCount, dependency.offsetData.typeMap)
        wasmData.typeCount += 1
      }
      // Increment The Number Of Types
      typeCount += numberOfTypes
      // Append The Type Section To The New Type Section
      Buffer.addBytes(
        Stream.nextSliceBytes(typeStream, Stream.remainingLength(typeStream)),
        typeSection
      )
    }
  }, dependencyChain)
  // Write The Section Header
  let wasmBinary = appendBufferByte(wasmBinary, 0x01) // Write Section ID
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(Buffer.length(typeSection) + 1)
  ) // Write Section Size
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(typeCount)
  ) // Write Type Count
  // Append The Type Section To The WasmBinary
  if (Buffer.length(typeSection) != 0) Buffer.addBuffer(typeSection, wasmBinary)
  // Return The Buffer
  wasmBinary
}
export let createImportSection = (wasmBinary, dependencyChain, wasmData) => {
  let mut importCount = 0
  let importSection = Buffer.make(0)
  // For Each Dependency
  List.forEach((dependency: DecodeFile.FileData) => {
    // Local Counts
    let mut localGlobalCount = 0
    let mut localFunctionCount = 0
    // Map Each Import
    List.forEach((wasmImport: WasmDecoder.WasmImport) => {
      // TODO: Link Together Brisk Imports
      if (wasmImport.briskImport && false) {
        void
      } else {
        // Get Import Properties
        let importModule = wasmImport.importModule
        let importName = wasmImport.importName
        let importDesc = wasmImport.importDescription
        // Map The Actual Import
        // TODO: We can only have one table import and one memory import so take the ones from the entryFile
        let importDesc = match (importDesc) {
          // typeDescription, typeRef
          WasmDecoder.FunctionImport(typeRef) => {
            Map.set(
              localFunctionCount,
              wasmData.functionCount,
              dependency.offsetData.functionMap
            )
            localFunctionCount += 1
            wasmData.functionCount += 1
            dependency.offsetData.importFunctionCount += 1
            match (Map.get(typeRef, dependency.offsetData.typeMap)) {
              Some(typeOffset) => WasmDecoder.FunctionImport(typeOffset),
              None => fail "Impossible: Type Not Found",
            }
          },
          WasmDecoder.GlobalImport(_, _) => {
            Map.set(
              localGlobalCount,
              wasmData.globalCount,
              dependency.offsetData.globalMap
            )
            localGlobalCount += 1
            wasmData.globalCount += 1
            dependency.offsetData.importGlobalCount += 1
            importDesc
          },
          _ => importDesc,
        }
        // Rebuild The Import
        appendBufferByteList(
          importSection,
          Encoder.encodeImport(importModule, importName, importDesc)
        )
        // Increment Import Count
        importCount += 1
      }
    }, dependency.wasmImports)
  }, dependencyChain)
  // Build The Header
  let wasmBinary = appendBufferByte(wasmBinary, 0x02) // Write Section ID
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(Buffer.length(importSection) + 1)
  ) // Write Section Size
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(importCount)
  ) // Write Import Count
  // Append The Import Section To The WasmBinary
  if (Buffer.length(importSection) != 0)
    Buffer.addBuffer(importSection, wasmBinary)
  // Return The Buffer
  wasmBinary
}
export let createFuncSection = (wasmBinary, dependencyChain, wasmData) => {
  let mut funcCount = 0
  let mut funcSection = Buffer.make(0)
  // For Each Dependency
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The Function Section
    let funcStream = getFuncSection(dependency.wasmSections)
    let functionCount = Stream.nextUIntLEB128(funcStream)
    // Map The Function Section
    for (let mut i = 0; i < functionCount; i += 1) {
      // Write The Offset
      Map.set(
        i + dependency.offsetData.importFunctionCount,
        wasmData.functionCount,
        dependency.offsetData.functionMap
      )
      wasmData.functionCount += 1
      // Get The TypeRef
      let typeRef = Stream.nextUIntLEB128(funcStream)
      // Add The Offset
      match (Map.get(typeRef, dependency.offsetData.typeMap)) {
        Some(typeOffset) => {
          funcSection = appendBufferByteList(
            funcSection,
            Encoder.encodeUIntLeb128(typeOffset)
          )
          funcCount += 1
        },
        None => fail "Impossible: Type Not Found",
      }
    }
  }, dependencyChain)
  // TODO: Add An Additional Function For The New Entry Function
  // Write The Section Header
  let wasmBinary = appendBufferByte(wasmBinary, 0x03) // Write Section ID
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(Buffer.length(funcSection) + 1)
  ) // Write Section Size
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(funcCount)
  ) // Write Func Count
  // Append The Function Section To The WasmBinary
  if (Buffer.length(funcSection) != 0) Buffer.addBuffer(funcSection, wasmBinary)
  // Return The Buffer
  wasmBinary
}
export let createTableSection = (wasmBinary, dependencyChain, wasmData) => {
  // TODO: Once wasm supports multiple tables allocate a table per dependency
  let mut initialTableSize = 0
  List.forEach((dependency: DecodeFile.FileData) => {
    let tableSection = getTableSection(dependency.wasmSections)
    // Skip the tableCount, tableType, flagType until wasm has multiple tables
    tableSection.position += 3
    initialTableSize += Stream.nextByte(tableSection)
  }, dependencyChain)
  // Write The Table Section
  // TODO: This might need to change if the initialTable size overflows one byte then i think we need to account for it in sectionSize
  let wasmBinary = appendBufferByte(wasmBinary, 0x04) // Write Section ID
  let wasmBinary = appendBufferByteList(wasmBinary, Encoder.encodeUIntLeb128(4))
  let wasmBinary = appendBufferByteList(wasmBinary, Encoder.encodeUIntLeb128(1))
  let wasmBinary = appendBufferByte(wasmBinary, 0x70) // Write Table Type
  let wasmBinary = appendBufferByte(wasmBinary, 0x00) // Write Flag Type
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(initialTableSize)
  )
  // Return The Buffer
  wasmBinary
}
export let createMemorySection = (wasmBinary, dependencyChain, wasmData) => {
  // Return The Buffer
  wasmBinary
}
export let createGlobalSection = (wasmBinary, dependencyChain, wasmData) => {
  let mut globalCount = 0
  let mut globalSection = Buffer.make(0)
  // For Each Dependency
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The GlobalStream
    let globalStream = getGlobalSection(dependency.wasmSections)
    // Get The Global Count
    let localGlobalCount = Stream.nextUIntLEB128(globalStream)
    globalCount += localGlobalCount
    // Map The Offsets
    for (let mut i = 0; i < localGlobalCount; i += 1) {
      // Write The Offset
      Map.set(
        i + dependency.offsetData.importGlobalCount,
        wasmData.globalCount,
        dependency.offsetData.globalMap
      )
      wasmData.globalCount += 1
    }
    // Write The Globals
    Buffer.addBytes(
      Stream.nextSliceBytes(globalStream, Stream.remainingLength(globalStream)),
      globalSection
    )
  }, dependencyChain)
  // Write The Header
  let wasmBinary = appendBufferByte(wasmBinary, 0x06) // Write Section ID
  // TODO: I think we need to fix this to account for globalCount
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(Buffer.length(globalSection) + 1)
  ) // Write Section Size
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(globalCount)
  ) // Write Global Count
  // Append The Global Section To The WasmBinary
  if (Buffer.length(globalSection) != 0)
    Buffer.addBuffer(globalSection, wasmBinary)
  // Return The Buffer
  wasmBinary
}
export let createExportSection = (wasmBinary, dependencyChain, wasmData) => {
  // Return The Buffer
  wasmBinary
}
export let createStartSection = (wasmBinary, dependencyChain, wasmData) => {
  // TODO: Set The Start Function To The Last Function As The Last Function is our new entry point
  // Return The Buffer
  wasmBinary
}
export let createElementSection = (wasmBinary, dependencyChain, wasmData) => {
  // Return The Buffer
  wasmBinary
}
export let createCodeSection = (wasmBinary, dependencyChain, wasmData) => {
  let mut codeCount = 0
  let mut codeSection = Buffer.make(0)
  // For Each Dependency
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The CodeStream
    let codeStream = getCodeSection(dependency.wasmSections)
    // Get The Function Count
    let functionCount = Stream.nextUIntLEB128(codeStream)
    for (let mut i = 0; i < functionCount; i += 1) {
      // For Each Reference
      match (List.nth(i, dependency.codeReferences)) {
        Some(funcRefs) => {
          // Get The Function Size
          let functionEnd = Stream.nextUIntLEB128(codeStream) +
            codeStream.position
          // Create A Temporary Buffer
          let mut funcBuffer = Buffer.make(0)
          // For Each Reference
          let mut lastPosition = 0
          List.forEach(ref => {
            // Get The Related Information
            let refPosition = match (ref) {
              DecodeSection.FunctionRef(ref) | DecodeSection.TypeRef(ref) |
              DecodeSection.GlobalRef(ref) =>
                ref,
            }
            // Copy The Stuff Before The Reference
            Buffer.addBytes(
              Stream.nextSliceBytes(codeStream, refPosition - lastPosition),
              funcBuffer
            )
            // Set The Last Position
            lastPosition = refPosition + 1
            // Write The Mapped Reference
            let mut refValue = Stream.nextUIntLEB128(codeStream)
            let refValue = match (ref) {
              DecodeSection.TypeRef(_) => {
                match (Map.get(refValue, dependency.offsetData.typeMap)) {
                  Some(refValue) => refValue,
                  None => fail "Impossible Type Not Found",
                }
              },
              DecodeSection.GlobalRef(_) => {
                match (Map.get(refValue, dependency.offsetData.globalMap)) {
                  Some(refValue) => refValue,
                  None => fail "Impossible Global Not Found",
                }
              },
              // TODO: Switch this to use maps
              DecodeSection.FunctionRef(_) => {
                match (Map.get(refValue, dependency.offsetData.functionMap)) {
                  Some(refValue) => refValue,
                  None => fail "Impossible Global Not Found",
                }
              },
            }
            funcBuffer = appendBufferByteList(
              funcBuffer,
              Encoder.encodeUIntLeb128(refValue)
            )
          }, funcRefs)
          if (Stream.remainingLength(codeStream) > 0) {
            // Write The Remaining Stuff
            Buffer.addBytes(
              Stream.nextSliceBytes(
                codeStream,
                functionEnd - codeStream.position
              ),
              funcBuffer
            )
          }
          // Write Function Header
          let codeSection = appendBufferByteList(
            codeSection,
            Encoder.encodeUIntLeb128(Buffer.length(funcBuffer))
          ) // Write Function Size
          Buffer.addBuffer(funcBuffer, codeSection)
        },
        None => fail "Could Not Find Related Linking Info",
      }
      // Increment The Code Count
      codeCount += 1
    }
  }, dependencyChain)
  // TODO: Add An Additional Function For The New Entry Function
  // Write The Section Header
  let wasmBinary = appendBufferByte(wasmBinary, 0x0a) // Write Section ID
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(Buffer.length(codeSection) + 1)
  ) // Write Section Size
  let wasmBinary = appendBufferByteList(
    wasmBinary,
    Encoder.encodeUIntLeb128(codeCount)
  ) // Write Code Count
  // Append The Function Section To The WasmBinary
  if (Buffer.length(codeSection) != 0) Buffer.addBuffer(codeSection, wasmBinary)
  // Return The Buffer
  wasmBinary
}
export let createDataSection = (wasmBinary, dependencyChain, wasmData) => {
  // Create Data Section
  // Create Data Count Section
  // Return The Buffer
  wasmBinary
}
// Build The File
export let buildFile = dependencyChain => {
  // Create Wasm Data
  let wasmData = { globalCount: 0, typeCount: 0, functionCount: 0 }
  // Create The Buffer To Hold The File
  let wasmBinary = Buffer.make(0)
  // Add The Magic Wasm Headers
  let wasmBinary = appendBufferByteList(wasmBinary, [0x00, 0x61, 0x73, 0x6d])
  let wasmBinary = appendBufferByteList(wasmBinary, [0x01, 0x00, 0x00, 0x00])
  // TODO: Create The Custom Sections
  // TODO: Remap The Name Section
  // TODO: Build A New Linking Info Sections
  // Build Sections
  let wasmBinary = createTypeSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createImportSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createFuncSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createTableSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createMemorySection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createGlobalSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createExportSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createStartSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createElementSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createCodeSection(wasmBinary, dependencyChain, wasmData)
  let wasmBinary = createDataSection(wasmBinary, dependencyChain, wasmData)
  // Return The File
  Buffer.toString(wasmBinary)
}
