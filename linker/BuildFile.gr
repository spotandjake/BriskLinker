// Imports
import Buffer from "buffer"
import List from "list"
import Map from "map"
import Int32 from "int32"
import Bytes from "bytes"
import Stream from "./Stream"
import DecodeSection, {
  getTypeSection,
  getFuncSection,
  getTableSection,
  getMemorySection,
  getGlobalSection,
  getStartSection,
  getCodeSection,
} from "./Decoder/DecodeSection"
import WasmDecoder from "./Decoder/WasmDecoder"
import Encoder from "./encode"
// Type Imports
import DecodeFile from "./Decoder/DecodeFile"
// WasmBinary Type
record WasmBinary {
  mut customSections: List<Buffer.Buffer>, // customSection[]
  mut typeSection: List<(Number, Bytes)>, // (typeCount, typeContent)[]
  mut importSection: List<Buffer.Buffer>, // import[]
  mut funcSection: List<(Buffer.Buffer, Buffer.Buffer)
  >, // (functionType, functionBody)[]
  mut tableSection: List<Buffer.Buffer>, // table[]
  mut memorySection: List<Buffer.Buffer>, // memory[]
  mut globalSection: List<(Number, Bytes)>, // (globalCount, globalContent)[]
  mut exportSection: List<Buffer.Buffer>, // export[]
  mut startSection: Buffer.Buffer, // startFunction
  mut elementSection: List<Buffer.Buffer>, // element[]
  mut dataSection: List<Buffer.Buffer>, // dataSection[]
}
// Types
record WasmData {
  mut globalCount: Number,
  mut typeCount: Number,
  mut funcCount: Number,
}
// Buffer Manipulation
let appendBufferByte = (buffer, byte) => {
  Buffer.addInt8(Int32.fromNumber(byte), buffer)
  buffer
}
let appendBufferByteList = (buffer, byteList) => {
  let mut buffer = buffer
  List.forEach(byte => {
    buffer = appendBufferByte(buffer, byte)
    void
  }, byteList)
  buffer
}
let listToBuffer = byteList => appendBufferByteList(Buffer.make(0), byteList)
// Create The Sections
export let createTypeSection = (wasmBinary, dependencyChain, wasmData) => {
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The Type Section
    let typeStream = getTypeSection(dependency.wasmSections)
    // Split The Types
    let depTypeCount = Stream.nextUIntLEB128(typeStream)
    wasmBinary.typeSection = List.append(
      [(depTypeCount, Stream.remainingBytes(typeStream))],
      wasmBinary.typeSection
    )
    // Map The Types
    for (let mut i = 0; i < depTypeCount; i += 1) {
      // Write The Offset
      Map.set(i, wasmData.typeCount, dependency.offsetData.typeMap)
      wasmData.typeCount += 1
    }
  }, dependencyChain)
}
export let createImportSection = (wasmBinary, dependencyChain, wasmData) => {
  // TODO: Find a more compact format for this
  List.forEach((dependency: DecodeFile.FileData) => {
    // Create local Counts
    let mut localFunctionCount = 0
    let mut localGlobalCount = 0
    // For Each Import
    List.forEach((wasmImport: WasmDecoder.WasmImport) => {
      // TODO: Handle Linking Brisk Imports To Brisk Exports
      if (wasmImport.briskImport && false) {
        void
      } else {
        // Map The Actual Import
        // TODO: We can only have one table import and one memory import so take the ones from the entryFile
        let importDesc = match (wasmImport.importDescription) {
          WasmDecoder.FunctionImport(typeRef) => {
            // Map The Value
            Map.set(
              localFunctionCount,
              wasmData.funcCount,
              dependency.offsetData.funcMap
            )
            localFunctionCount += 1
            wasmData.funcCount += 1
            dependency.offsetData.importFunctionCount += 1
            match (Map.get(typeRef, dependency.offsetData.typeMap)) {
              Some(typeOffset) => WasmDecoder.FunctionImport(typeOffset),
              None => fail "Impossible: Type Not Found",
            }
          },
          WasmDecoder.GlobalImport(_, _) => {
            Map.set(
              localGlobalCount,
              wasmData.globalCount,
              dependency.offsetData.globalMap
            )
            localGlobalCount += 1
            wasmData.globalCount += 1
            dependency.offsetData.importGlobalCount += 1
            wasmImport.importDescription
          },
          _ => wasmImport.importDescription,
        }
        // Rebuild The Import
        wasmBinary.importSection = [
          listToBuffer(
            Encoder.encodeImport(
              wasmImport.importModule,
              wasmImport.importName,
              importDesc
            )
          ),
          ...wasmBinary.importSection
        ]
      }
    }, List.reverse(dependency.wasmImports))
  }, List.reverse(dependencyChain))
}
export let createFuncSection = (wasmBinary, dependencyChain, wasmData) => {
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The Function Section
    let funcStream = getFuncSection(dependency.wasmSections)
    let codeStream = getCodeSection(dependency.wasmSections)
    // Get The Function Count
    let funcCount = Stream.nextUIntLEB128(funcStream)
    Stream.advance(codeStream, 1)
    // For Each Function
    let functions = List.init(funcCount, funcIndex => {
      // Map The Function header
      let funcSection = match (Map.get(
        Stream.nextUIntLEB128(funcStream),
        dependency.offsetData.typeMap
      )) {
        Some(typeOffset) => {
          listToBuffer(Encoder.encodeUIntLeb128(typeOffset))
        },
        None => fail "Impossible: Type Not Found",
      }
      // Map The Function Index
      Map.set(
        funcIndex + dependency.offsetData.importFunctionCount,
        wasmData.funcCount,
        dependency.offsetData.funcMap
      )
      wasmData.funcCount += 1
      // Get The Function Body
      let funcBodySize = Stream.nextUIntLEB128(codeStream)
      let funcBodyContent = Stream.nextStreamSlice(codeStream, funcBodySize)
      let mut funcBody = Buffer.make(0)
      // Map The Function Body
      match (List.nth(funcIndex, dependency.codeReferences)) {
        Some(codeRefs) => {
          List.forEach(codeRef => {
            // Get The Reference Data
            let (refPosition, refMap) = match (codeRef) {
              DecodeSection.FuncRef(pos) =>
                (pos, dependency.offsetData.funcMap),
              DecodeSection.TypeRef(pos) =>
                (pos, dependency.offsetData.typeMap),
              DecodeSection.GlobalRef(pos) =>
                (pos, dependency.offsetData.globalMap),
            }
            // TODO: Write The Stuff Before The Reference
            Buffer.addBytes(
              Stream.nextSliceBytes(
                funcBodyContent,
                refPosition - funcBodyContent.position
              ),
              funcBody
            )
            // Write The Reference
            let refValue = Stream.nextUIntLEB128(funcBodyContent)
            let refValue = match (Map.get(refValue, refMap)) {
              Some(value) => value,
              None => fail "Impossible: Reference Not Found",
            }
            funcBody = appendBufferByteList(
              funcBody,
              Encoder.encodeUIntLeb128(refValue)
            )
          }, codeRefs)
        },
        None => fail "Impossible: Function Does Not Have Linking Info",
      }
      // Write The Remaining Stuff
      Buffer.addBytes(Stream.remainingBytes(funcBodyContent), funcBody)
      let codeBody = listToBuffer(Encoder.encodeUIntLeb128(funcBodySize))
      Buffer.addBuffer(funcBody, codeBody)
      // Return The Function Content
      (funcSection, codeBody)
    })
    // Write The Function Data To The Binary
    wasmBinary.funcSection = List.append(wasmBinary.funcSection, functions)
  }, dependencyChain)
}
export let createTableSection = (wasmBinary, dependencyChain, wasmData) => {
  // TODO: Once wasm supports multiple tables allocate a table per dependency
  let mut initialTableSize = 0
  List.forEach((dependency: DecodeFile.FileData) => {
    let tableSection = getTableSection(dependency.wasmSections)
    // Skip the tableCount, tableType, flagType until wasm has multiple tables
    Stream.advance(tableSection, 3)
    initialTableSize += Stream.nextByte(tableSection)
  }, dependencyChain)
  // Write The Table Section
  // tableType, flagType, initialCount
  let table = listToBuffer(
    [0x70, 0x00, ...Encoder.encodeUIntLeb128(initialTableSize)]
  )
  wasmBinary.tableSection = [table, ...wasmBinary.tableSection]
}
export let createMemorySection = (wasmBinary, dependencyChain, wasmData) => {
  // TODO: Once wasm supports multiple memories consider using a separate memory per dependency
  let mut initialMemorySize = 0
  List.forEach((dependency: DecodeFile.FileData) => {
    let memorySection = getMemorySection(dependency.wasmSections)
    // Skip the tableCount, flagType until wasm has multiple memories
    Stream.advance(memorySection, 2)
    initialMemorySize += Stream.nextByte(memorySection)
  }, dependencyChain)
  // Write The Table Section
  wasmBinary.memorySection = [
    listToBuffer([0x00, ...Encoder.encodeUIntLeb128(initialMemorySize)]),
    ...wasmBinary.memorySection
  ]
}
export let createGlobalSection = (wasmBinary, dependencyChain, wasmData) => {
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The Type Section
    let globalStream = getGlobalSection(dependency.wasmSections)
    // Split The Types
    let depGlobalCount = Stream.nextUIntLEB128(globalStream)
    wasmBinary.globalSection = [
      (depGlobalCount, Stream.remainingBytes(globalStream)),
      ...wasmBinary.globalSection
    ]
    // Map The Types
    for (let mut i = 0; i < depGlobalCount; i += 1) {
      // Write The Offset
      Map.set(
        i + dependency.offsetData.importGlobalCount,
        wasmData.globalCount,
        dependency.offsetData.globalMap
      )
      wasmData.globalCount += 1
    }
  }, dependencyChain)
}
export let createExportSection = (wasmBinary, dependencyChain, wasmData) => {
  // Return The Buffer
  wasmBinary
}
export let createStartSection = (wasmBinary, dependencyChain, wasmData) => {
  let mut startFunction = Buffer.make(0)
  // TODO: Set The Start Function To The Last Function As The Last Function is our new entry point
  List.forEach((dependency: DecodeFile.FileData) => {
    // Get The Start Section
    let startStream = getStartSection(dependency.wasmSections)
    // If There is no start section, skip
    if (Stream.length(startStream) != 0) {
      // Parse The Start Section
      let startFunctionIndex = Stream.nextUIntLEB128(startStream)
      // Map The Start Function
      let startFunctionIndex = match (Map.get(
        startFunctionIndex,
        dependency.offsetData.funcMap
      )) {
        Some(funcIndex) => funcIndex,
        None => fail "Impossible: Reference Not Found",
      }
      // Append A Function Call To The New Start Function Body
      startFunction = appendBufferByteList(
        startFunction,
        [0x10, ...Encoder.encodeUIntLeb128(startFunctionIndex)]
      )
    }
  }, dependencyChain)
  // Build The Start Function Type
  let startFunctionType = listToBuffer([0x60, 0x00, 0x00])
  // TODO: Clean This Up
  wasmBinary.typeSection = [
    (1, Buffer.toBytes(startFunctionType)),
    ...wasmBinary.typeSection
  ]
  // Build The New Start Function
  let startFunctionHeader = listToBuffer(
    Encoder.encodeUIntLeb128(wasmData.typeCount)
  )
  let startFunctionBody = appendBufferByte(
    Buffer.make(0),
    0x00
  ) // Local Count is 0
  Buffer.addBuffer(startFunction, startFunctionBody)
  let startFunctionBody = appendBufferByte(
    startFunctionBody,
    0x0b
  ) // Push end instruction
  let funcBody = listToBuffer(
    Encoder.encodeUIntLeb128(Buffer.length(startFunctionBody))
  )
  Buffer.addBuffer(startFunctionBody, funcBody)
  // Push The Start Function
  wasmBinary.funcSection = List.append(
    wasmBinary.funcSection,
    [(startFunctionHeader, funcBody)]
  )
  // Push the Encoded Start Function Index
  wasmBinary.startSection = listToBuffer(
    Encoder.encodeUIntLeb128(wasmData.funcCount)
  )
}
export let createElementSection = (wasmBinary, dependencyChain, wasmData) => {
  // Return The Buffer
  wasmBinary
}
export let createDataSection = (wasmBinary, dependencyChain, wasmData) => {
  // Create Data Section
  // Create Data Count Section
  // Return The Buffer
  wasmBinary
}
// Rebuild WasmBinary
export let buildBinary = wasmBinaryContent => {
  // Helpers
  let encodeSection = (sectionID, sectionContent) => {
    let sectionBuffer = listToBuffer(
      [sectionID, ...Encoder.encodeUIntLeb128(Buffer.length(sectionContent))]
    )
    Buffer.addBuffer(sectionContent, sectionBuffer)
    sectionBuffer
  }
  let encodeSectionWithCount = (sectionID, count, sectionContent) => {
    let wasmSection = listToBuffer(Encoder.encodeUIntLeb128(count))
    Buffer.addBuffer(sectionContent, wasmSection)
    encodeSection(sectionID, wasmSection)
  }
  // Build The Sections
  // TODO: Build The Custom Sections
  // Build The Type Section
  let mut typeCount = 0
  let typeSection = Buffer.make(0)
  List.forEach(((depTypeCount, depTypeSection)) => {
    Buffer.addBytes(depTypeSection, typeSection)
    typeCount += depTypeCount
  }, List.reverse(wasmBinaryContent.typeSection))
  let typeSection = encodeSectionWithCount(0x01, typeCount, typeSection)
  // Build The ImportSection
  let importSection = Buffer.make(0)
  List.forEach(depImport => {
    Buffer.addBuffer(depImport, importSection)
  }, wasmBinaryContent.importSection)
  let importSection = encodeSectionWithCount(
    0x02,
    List.length(wasmBinaryContent.importSection),
    importSection
  )
  // Build The Function Sections
  let funcSection = Buffer.make(0)
  let codeSection = Buffer.make(0)
  let funcCount = List.length(wasmBinaryContent.funcSection)
  List.forEach(((funcHeader, funcBody)) => {
    Buffer.addBuffer(funcHeader, funcSection)
    Buffer.addBuffer(funcBody, codeSection)
  }, wasmBinaryContent.funcSection)
  let funcSection = encodeSectionWithCount(0x03, funcCount, funcSection)
  let codeSection = encodeSectionWithCount(0x0a, funcCount, codeSection)
  // Build The Table Section
  let tableSection = Buffer.make(0)
  List.forEach(depImport => {
    Buffer.addBuffer(depImport, tableSection)
  }, wasmBinaryContent.tableSection)
  let tableSection = encodeSectionWithCount(
    0x04,
    List.length(wasmBinaryContent.tableSection),
    tableSection
  )
  // Build The Memory Section
  let memorySection = Buffer.make(0)
  List.forEach(depImport => {
    Buffer.addBuffer(depImport, memorySection)
  }, wasmBinaryContent.memorySection)
  let memorySection = encodeSectionWithCount(
    0x05,
    List.length(wasmBinaryContent.memorySection),
    memorySection
  )
  // Build The Global Section
  let mut globalCount = 0
  let globalSection = Buffer.make(0)
  List.forEach(((depGlobalCount, depGlobalSection)) => {
    Buffer.addBytes(depGlobalSection, globalSection)
    globalCount += depGlobalCount
  }, List.reverse(wasmBinaryContent.globalSection))
  let globalSection = encodeSectionWithCount(0x06, globalCount, globalSection)
  // TODO: Build The Export Section
  // Build The Start Section
  let startSection = encodeSection(0x08, wasmBinaryContent.startSection)
  // TODO: Build The Element Section
  // TODO: Build The Data Section
  // TODO: Build The Data Count Section
  // Create The Binary
  let wasmBinary = Buffer.make(0)
  let wasmBinary = appendBufferByteList(wasmBinary, [0x00, 0x61, 0x73, 0x6d])
  let wasmBinary = appendBufferByteList(wasmBinary, [0x01, 0x00, 0x00, 0x00])
  // TODO: Combine The Sections Into A Binary
  Buffer.addBuffer(typeSection, wasmBinary)
  Buffer.addBuffer(importSection, wasmBinary)
  Buffer.addBuffer(funcSection, wasmBinary)
  Buffer.addBuffer(tableSection, wasmBinary)
  Buffer.addBuffer(memorySection, wasmBinary)
  Buffer.addBuffer(globalSection, wasmBinary)
  // let wasmBinary = createExportSection(wasmBinary, dependencyChain, wasmData)
  Buffer.addBuffer(startSection, wasmBinary)
  // let wasmBinary = createElementSection(wasmBinary, dependencyChain, wasmData)
  Buffer.addBuffer(codeSection, wasmBinary)
  // let wasmBinary = createDataSection(wasmBinary, dependencyChain, wasmData)
  // Return The Binary
  wasmBinary
}
// Build The File
export let buildFile = dependencyChain => {
  // Create Wasm Data
  let wasmData = { globalCount: 0, typeCount: 0, funcCount: 0 }
  // Create The Wasm Binary Content
  let wasmBinaryContent = {
    customSections: [],
    typeSection: [],
    importSection: [],
    funcSection: [],
    tableSection: [],
    memorySection: [],
    globalSection: [],
    exportSection: [],
    startSection: Buffer.make(0),
    elementSection: [],
    dataSection: [],
  }
  // Build Sections
  createTypeSection(wasmBinaryContent, dependencyChain, wasmData)
  createImportSection(wasmBinaryContent, dependencyChain, wasmData)
  createGlobalSection(wasmBinaryContent, dependencyChain, wasmData)
  createFuncSection(wasmBinaryContent, dependencyChain, wasmData)
  createTableSection(wasmBinaryContent, dependencyChain, wasmData)
  createMemorySection(wasmBinaryContent, dependencyChain, wasmData)
  // let wasmBinary = createExportSection(wasmBinary, dependencyChain, wasmData)
  createStartSection(wasmBinaryContent, dependencyChain, wasmData)
  // let wasmBinary = createElementSection(wasmBinary, dependencyChain, wasmData)
  // let wasmBinary = createDataSection(wasmBinary, dependencyChain, wasmData)
  // Build The Binary
  let wasmBinary = buildBinary(wasmBinaryContent)
  // Return The File
  Buffer.toString(wasmBinary)
}
